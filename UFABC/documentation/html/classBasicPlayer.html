<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Trilinear: BasicPlayer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Trilinear
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classBasicPlayer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BasicPlayer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="BasicPlayer_8h_source.html">BasicPlayer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BasicPlayer:</div>
<div class="dyncontent">
<div class="center"><img src="classBasicPlayer__inherit__graph.png" border="0" usemap="#BasicPlayer_inherit__map" alt="Inheritance graph"/></div>
<map name="BasicPlayer_inherit__map" id="BasicPlayer_inherit__map">
<area shape="rect" id="node2" href="classPlayer.html" title="Player" alt="" coords="22,80,81,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for BasicPlayer:</div>
<div class="dyncontent">
<div class="center"><img src="classBasicPlayer__coll__graph.png" border="0" usemap="#BasicPlayer_coll__map" alt="Collaboration graph"/></div>
<map name="BasicPlayer_coll__map" id="BasicPlayer_coll__map">
<area shape="rect" id="node2" href="classPlayerSettings.html" title="PlayerSettings" alt="" coords="5,95,112,121"/>
<area shape="rect" id="node3" href="classGenericValues.html" title="GenericValues" alt="" coords="60,5,167,32"/>
<area shape="rect" id="node6" href="classServerSettings.html" title="ServerSettings" alt="" coords="137,95,245,121"/>
<area shape="rect" id="node4" href="classWorldModel.html" title="WorldModel" alt="" coords="269,95,360,121"/>
<area shape="rect" id="node5" href="classTime.html" title="Time" alt="" coords="289,5,340,32"/>
<area shape="rect" id="node7" href="classActHandler.html" title="ActHandler" alt="" coords="385,95,471,121"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8110d9253af12626e3a404cfe476bed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a8110d9253af12626e3a404cfe476bed0">alignNeckWithBody</a> ()</td></tr>
<tr class="separator:a8110d9253af12626e3a404cfe476bed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4762b6f8a9938bd5142bee0865a72e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a4f4762b6f8a9938bd5142bee0865a72e">turnBodyToPoint</a> (<a class="el" href="classVecPosition.html">VecPosition</a> pos, int iPos=1)</td></tr>
<tr class="separator:a4f4762b6f8a9938bd5142bee0865a72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb667ad61ced5f4fea1b6552d7a218ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#acb667ad61ced5f4fea1b6552d7a218ca">turnBackToPoint</a> (<a class="el" href="classVecPosition.html">VecPosition</a> pos, int iPos=1)</td></tr>
<tr class="separator:acb667ad61ced5f4fea1b6552d7a218ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdeb44dc297eae5ea895a3adc1f40c44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdeb44dc297eae5ea895a3adc1f40c44"></a>
<a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><b>turnSideToPoint</b> (<a class="el" href="classVecPosition.html">VecPosition</a> pos, <a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> angle, int iCycles=1)</td></tr>
<tr class="separator:abdeb44dc297eae5ea895a3adc1f40c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651d2599323445ef450bd9af94c5c7ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a651d2599323445ef450bd9af94c5c7ca">turnNeckToPoint</a> (<a class="el" href="classVecPosition.html">VecPosition</a> pos, <a class="el" href="classSoccerCommand.html">SoccerCommand</a> com)</td></tr>
<tr class="separator:a651d2599323445ef450bd9af94c5c7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9700140b78ffeb1794366cf63836e21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#ad9700140b78ffeb1794366cf63836e21">searchBall</a> ()</td></tr>
<tr class="separator:ad9700140b78ffeb1794366cf63836e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7da70e5ce312ed3e4365531f050195f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#af7da70e5ce312ed3e4365531f050195f">dashToPoint</a> (<a class="el" href="classVecPosition.html">VecPosition</a> pos, int iCycles=1, bool sideDash=false)</td></tr>
<tr class="separator:af7da70e5ce312ed3e4365531f050195f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edbb52467b3952693bc5e86d6230473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a6edbb52467b3952693bc5e86d6230473">freezeBall</a> ()</td></tr>
<tr class="separator:a6edbb52467b3952693bc5e86d6230473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517b7d4ef489a3476662939019e1d66d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a517b7d4ef489a3476662939019e1d66d">kickBallCloseToBody</a> (<a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> ang, double dKickRatio=0.16)</td></tr>
<tr class="separator:a517b7d4ef489a3476662939019e1d66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebbd9fae54ebdca287d1c7aa2ce8b25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a3ebbd9fae54ebdca287d1c7aa2ce8b25">accelerateBallToVelocity</a> (<a class="el" href="classVecPosition.html">VecPosition</a> vel)</td></tr>
<tr class="separator:a3ebbd9fae54ebdca287d1c7aa2ce8b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61de8901846464425f2670dc4f976ab0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a61de8901846464425f2670dc4f976ab0">catchBall</a> ()</td></tr>
<tr class="separator:a61de8901846464425f2670dc4f976ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22df9c1f41ddd210ffc6d97e56a2b904"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a22df9c1f41ddd210ffc6d97e56a2b904">communicate</a> (char *str)</td></tr>
<tr class="separator:a22df9c1f41ddd210ffc6d97e56a2b904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ffa701a6b2da41c70b60a8c244d96d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a22ffa701a6b2da41c70b60a8c244d96d">teleportToPos</a> (<a class="el" href="classVecPosition.html">VecPosition</a> pos)</td></tr>
<tr class="separator:a22ffa701a6b2da41c70b60a8c244d96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9844c2ef6e7c53c604835c9423638a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a4e9844c2ef6e7c53c604835c9423638a">listenTo</a> (<a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a> obj)</td></tr>
<tr class="separator:a4e9844c2ef6e7c53c604835c9423638a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987d8442964607644adf5bcd539a0659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a987d8442964607644adf5bcd539a0659">tackle</a> (double powerOrAngle)</td></tr>
<tr class="separator:a987d8442964607644adf5bcd539a0659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9374629af78e897891ab992a21f85f2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a9374629af78e897891ab992a21f85f2a">turnBodyToObject</a> (<a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a> o)</td></tr>
<tr class="separator:a9374629af78e897891ab992a21f85f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8a6bc96a2cafcf33fd2f4daabc1de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#aaf8a6bc96a2cafcf33fd2f4daabc1de0">turnNeckToObject</a> (<a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a> o, <a class="el" href="classSoccerCommand.html">SoccerCommand</a> com)</td></tr>
<tr class="separator:aaf8a6bc96a2cafcf33fd2f4daabc1de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393a33539a9af09838e90c58428572cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a393a33539a9af09838e90c58428572cf"></a>
<a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><b>directTowards</b> (<a class="el" href="classVecPosition.html">VecPosition</a> posTo, <a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> angWhenToTurn, <a class="el" href="classVecPosition.html">VecPosition</a> *pos=NULL, <a class="el" href="classVecPosition.html">VecPosition</a> *vel=NULL, <a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> *angBody=NULL)</td></tr>
<tr class="separator:a393a33539a9af09838e90c58428572cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0310219cd313d63785a72d482db2348b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a0310219cd313d63785a72d482db2348b">moveToPos</a> (<a class="el" href="classVecPosition.html">VecPosition</a> posTo, <a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> angWhenToTurn, double dDistDashBack=0.0, bool bMoveBack=false, int iCycles=1)</td></tr>
<tr class="separator:a0310219cd313d63785a72d482db2348b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ab617e6e772c686efec2d94d780723"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a69ab617e6e772c686efec2d94d780723">moveToPos2</a> (<a class="el" href="classVecPosition.html">VecPosition</a> posTo, <a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> angWhenToTurn, double angle)</td></tr>
<tr class="separator:a69ab617e6e772c686efec2d94d780723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac84d06304774170af7b01162558da3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#aac84d06304774170af7b01162558da3e">collideWithBall</a> ()</td></tr>
<tr class="separator:aac84d06304774170af7b01162558da3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcee3b0e4dadf0305022280beaf5991e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#abcee3b0e4dadf0305022280beaf5991e">interceptClose</a> ()</td></tr>
<tr class="separator:abcee3b0e4dadf0305022280beaf5991e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a7e41c8b11d8fe6b92f950141a6ec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a93a7e41c8b11d8fe6b92f950141a6ec3">interceptCloseGoalie</a> ()</td></tr>
<tr class="separator:a93a7e41c8b11d8fe6b92f950141a6ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502eaf4aa2a5ba85af56f6863e767395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a502eaf4aa2a5ba85af56f6863e767395">kickTo</a> (<a class="el" href="classVecPosition.html">VecPosition</a> posTarget, double dEndSpeed)</td></tr>
<tr class="separator:a502eaf4aa2a5ba85af56f6863e767395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8241babfa3f51132484b2ff73af042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a6b8241babfa3f51132484b2ff73af042">turnWithBallTo</a> (<a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> ang, <a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> angKickThr, double dFreezeThr)</td></tr>
<tr class="separator:a6b8241babfa3f51132484b2ff73af042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e0fa368dc255e0d36c5d4b72d23899"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a05e0fa368dc255e0d36c5d4b72d23899">moveToPosAlongLine</a> (<a class="el" href="classVecPosition.html">VecPosition</a> pos, <a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> ang, double dDistThr, int iSign, <a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> angThr, <a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> angCorr)</td></tr>
<tr class="separator:a05e0fa368dc255e0d36c5d4b72d23899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b9642a2abd6f5f3fc359589d1373d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#af6b9642a2abd6f5f3fc359589d1373d6">intercept</a> (bool isGoalie)</td></tr>
<tr class="separator:af6b9642a2abd6f5f3fc359589d1373d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e33779fbadff1b61a499c4176ac6f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a63e33779fbadff1b61a499c4176ac6f4">dribble</a> (<a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> ang, <a class="el" href="SoccerTypes_8h.html#a0ccbf575eb8292e31644ccf3e84e3e3b">DribbleT</a> d)</td></tr>
<tr class="separator:a63e33779fbadff1b61a499c4176ac6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687cc07033c6546931971f570c1e3a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a687cc07033c6546931971f570c1e3a67">directPass</a> (<a class="el" href="classVecPosition.html">VecPosition</a> pos, <a class="el" href="SoccerTypes_8h.html#ab93ab6e2460fd3f4ae01757ea619ee30">PassT</a> passType)</td></tr>
<tr class="separator:a687cc07033c6546931971f570c1e3a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6793780826b51a126102c5d29707ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a9c6793780826b51a126102c5d29707ea">leadingPass</a> (<a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a> o, double dDist, <a class="el" href="SoccerTypes_8h.html#a8e832a4ec6c67d3151112ed1e1c67752">DirectionT</a> dir=<a class="el" href="SoccerTypes_8h.html#a8e832a4ec6c67d3151112ed1e1c67752a944af66843e2c071955de8dfc4e7f407">DIR_NORTH</a>)</td></tr>
<tr class="separator:a9c6793780826b51a126102c5d29707ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8ea920641ef60220f1ff9ce4975268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#aca8ea920641ef60220f1ff9ce4975268">throughPass</a> (<a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a> o, <a class="el" href="classVecPosition.html">VecPosition</a> posEnd, <a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> *angMax=NULL)</td></tr>
<tr class="separator:aca8ea920641ef60220f1ff9ce4975268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16c69a2f51d2eafd1e01ae6664059fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#ae16c69a2f51d2eafd1e01ae6664059fe">outplayOpponent</a> (<a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a> o, <a class="el" href="classVecPosition.html">VecPosition</a> pos, <a class="el" href="classVecPosition.html">VecPosition</a> *posTo=NULL)</td></tr>
<tr class="separator:ae16c69a2f51d2eafd1e01ae6664059fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f048f249f2180bf287932724660a63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a06f048f249f2180bf287932724660a63">clearBall</a> (<a class="el" href="SoccerTypes_8h.html#ae2955c91fd80f27b4c28cfd55a517e77">ClearBallT</a> type, <a class="el" href="SoccerTypes_8h.html#a8e9b8119c00121a197203aca01d5b090">SideT</a> s=<a class="el" href="SoccerTypes_8h.html#a8e9b8119c00121a197203aca01d5b090a15a5449d2724d5cf4a7855b32888b24a">SIDE_ILLEGAL</a>, <a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> *angMax=NULL)</td></tr>
<tr class="separator:a06f048f249f2180bf287932724660a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5217a00d71206eaf17bf3656bd6f995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#ac5217a00d71206eaf17bf3656bd6f995">mark</a> (<a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a> o, double dDist, <a class="el" href="SoccerTypes_8h.html#a4cc7adc5fa3df60a8143bd51fc421f92">MarkT</a> mark)</td></tr>
<tr class="separator:ac5217a00d71206eaf17bf3656bd6f995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6be860b141f47cb33eec9f0a3762dd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#ad6be860b141f47cb33eec9f0a3762dd8">defendGoalLine</a> (double dDist)</td></tr>
<tr class="separator:ad6be860b141f47cb33eec9f0a3762dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ea44e2d6f0105ae521c9ac9bf407ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a20ea44e2d6f0105ae521c9ac9bf407ea">interceptScoringAttempt</a> ()</td></tr>
<tr class="separator:a20ea44e2d6f0105ae521c9ac9bf407ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6927be949526b68617b8663eae9e2b7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a6927be949526b68617b8663eae9e2b7d">holdBall</a> ()</td></tr>
<tr class="separator:a6927be949526b68617b8663eae9e2b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803fc819ba92d02bf244d883f0f76203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a803fc819ba92d02bf244d883f0f76203">getThroughPassShootingPoint</a> (<a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a> objTeam, <a class="el" href="classVecPosition.html">VecPosition</a> posEnd, <a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> *angMax)</td></tr>
<tr class="separator:a803fc819ba92d02bf244d883f0f76203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cd1d09c374231ae78e10d0636a644d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#af6cd1d09c374231ae78e10d0636a644d">getInterceptionPointBall</a> (int *iCyclesBall, bool isGoalie)</td></tr>
<tr class="separator:af6cd1d09c374231ae78e10d0636a644d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b50d5fb9c7fa0e5a90a7e4a215bafc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a1b50d5fb9c7fa0e5a90a7e4a215bafc0">getActiveInterceptionPointBall</a> (int *iCyclesBall, bool isGoalie)</td></tr>
<tr class="separator:a1b50d5fb9c7fa0e5a90a7e4a215bafc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4e9c5d0045117bc4ecfc75fc5b690c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c4e9c5d0045117bc4ecfc75fc5b690c"></a>
<a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getDribblePoint</b> (<a class="el" href="SoccerTypes_8h.html#a0ccbf575eb8292e31644ccf3e84e3e3b">DribbleT</a> <a class="el" href="classBasicPlayer.html#a63e33779fbadff1b61a499c4176ac6f4">dribble</a>, double *dDist)</td></tr>
<tr class="separator:a9c4e9c5d0045117bc4ecfc75fc5b690c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2b1236c259554ebdf96914ed2adb4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#abf2b1236c259554ebdf96914ed2adb4f">getShootPositionOnLine</a> (<a class="el" href="classVecPosition.html">VecPosition</a> p1, <a class="el" href="classVecPosition.html">VecPosition</a> p2, <a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> *angLargest=NULL)</td></tr>
<tr class="separator:abf2b1236c259554ebdf96914ed2adb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d6ecdb0d5f39f2644dc85e0da8cf3e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a95d6ecdb0d5f39f2644dc85e0da8cf3e">getEndSpeedForPass</a> (<a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a> o, <a class="el" href="classVecPosition.html">VecPosition</a> posPass)</td></tr>
<tr class="separator:a95d6ecdb0d5f39f2644dc85e0da8cf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914a86746493fefae4af754011b4150e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a914a86746493fefae4af754011b4150e">getMarkingPosition</a> (<a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a> o, double dDist, <a class="el" href="SoccerTypes_8h.html#a4cc7adc5fa3df60a8143bd51fc421f92">MarkT</a> <a class="el" href="classBasicPlayer.html#ac5217a00d71206eaf17bf3656bd6f995">mark</a>)</td></tr>
<tr class="separator:a914a86746493fefae4af754011b4150e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05baabe77a35927934f2955deed50480"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05baabe77a35927934f2955deed50480"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getPlayerVersion</b> ()</td></tr>
<tr class="separator:a05baabe77a35927934f2955deed50480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed979d279cb483bf8d5331d8cba0cd09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed979d279cb483bf8d5331d8cba0cd09"></a>
<a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><b>syncSee</b> ()</td></tr>
<tr class="separator:aed979d279cb483bf8d5331d8cba0cd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adb559ebfe52c2ca1b01cc21655bbed10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classActHandler.html">ActHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#adb559ebfe52c2ca1b01cc21655bbed10">ACT</a></td></tr>
<tr class="separator:adb559ebfe52c2ca1b01cc21655bbed10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0a8b87ce4d8b6ad94a0fe594274715"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWorldModel.html">WorldModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a0a0a8b87ce4d8b6ad94a0fe594274715">WM</a></td></tr>
<tr class="separator:a0a0a8b87ce4d8b6ad94a0fe594274715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16daddc5f23e5862d115d1913a93fc1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classServerSettings.html">ServerSettings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#a16daddc5f23e5862d115d1913a93fc1d">SS</a></td></tr>
<tr class="separator:a16daddc5f23e5862d115d1913a93fc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9a4fafd096a406d0ef5f85d11907b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPlayerSettings.html">PlayerSettings</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasicPlayer.html#aef9a4fafd096a406d0ef5f85d11907b8">PS</a></td></tr>
<tr class="separator:aef9a4fafd096a406d0ef5f85d11907b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd93798246ad9f9c0d7d544d7439488"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bd93798246ad9f9c0d7d544d7439488"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>dPlayerVersion</b></td></tr>
<tr class="separator:a9bd93798246ad9f9c0d7d544d7439488"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class defines the skills that can be used by an agent. No functionality is available that chooses when to execute which skill, this is done in the <a class="el" href="classPlayer.html">Player</a> class. The <a class="el" href="classWorldModel.html">WorldModel</a> is used to determine the way in which the skills are performed. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3ebbd9fae54ebdca287d1c7aa2ce8b25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::accelerateBallToVelocity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>velDes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to accelerate the ball in such a way that it gets a certain velocity after the kick. It receives the desired velocity 'vecDes' as its only argument and returns a kick command that causes the ball to be accelerated to this velocity. If the power that must be supplied to the kick command to get the desired result does not exceed the maximum kick power then the desired velocity can be realized with a single kick. The kick direction should then be equal to the direction of the acceleration vector relative to the agent's global body angle. However, if the desired velocity is too great or if the current ball velocity is too high then the required acceleration cannot be realized with a single kick. In this case, the ball is kicked in such a way that the acceleration vector has the maximum possible length and a direction that aligns the resulting ball movement with 'vecDes'. This means that after the kick the ball will move in the same direction as 'vecDes' but at a lower speed. To this end the acceleration vector has to compensate for the current ball velocity in the `wrong' direction (y-component). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">velDes</td><td>desired ball velocity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> that accelerates the ball to 'vecDes' </dd></dl>

</div>
</div>
<a class="anchor" id="a8110d9253af12626e3a404cfe476bed0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::alignNeckWithBody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to align his neck with his body. It returns a turn neck command that takes the angle of the agent's body relative to his neck as its only argument. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> turn_neck command that aligns neck with body </dd></dl>

</div>
</div>
<a class="anchor" id="a61de8901846464425f2670dc4f976ab0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::catchBall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to catch the ball and can only be executed when the agent is a goalkeeper. It returns a catch command that takes the angle of the ball relative to the body of the agent as its only argument. The correct value for this argument is computed by determining the global direction between the current ball position and the agent's current position and by making this direction relative to the agent's global body angle. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to catch the ball </dd></dl>

</div>
</div>
<a class="anchor" id="a06f048f249f2180bf287932724660a63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::clearBall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#ae2955c91fd80f27b4c28cfd55a517e77">ClearBallT</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#a8e9b8119c00121a197203aca01d5b090">SideT</a>&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="SoccerTypes_8h.html#a8e9b8119c00121a197203aca01d5b090a15a5449d2724d5cf4a7855b32888b24a">SIDE_ILLEGAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> *&#160;</td>
          <td class="paramname"><em>angMax</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to clear the ball to a certain area on the field. It is useful, for example, when a defender cannot dribble or pass the ball to a teammate in a dangerous situation. Using this skill he can then kick the ball up the field away from the defensive zone. It is important to realize that this skill is only called when the agent has no alternative options in the current situation. Clearing the ball amounts to kicking it with maximum power into the widest angle between opponents in a certain area. The shooting direction is determined using the function which returns the direction of the bisector of this widest angle. The area on the field from which this angle is selected depends on the type of clear which is supplied as an argument to this skill. We distinguish three types of clearing:</p><ul>
<li>CLEAR BALL DEFENSIVE: clearing the ball away from the defensive zone into a triangular area which is defined by the current ball position and the center line on the field.</li>
<li>CLEAR BALL OFFENSIVE: clearing the ball towards the offensive zone into a triangular area which is defined by the current ball position and the line segment that coincides with the front line of the opponent's penalty area and extends to the left and right side lines.</li>
<li>CLEAR BALL GOAL: clearing the ball into a triangular area in front of the opponent's goal which is defined by the current ball position and the line segment that runs from the center of the opponent's goal to the center of the front line of the penalty area. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of the clear ball skill </td></tr>
    <tr><td class="paramname">s</td><td>if specified indicates the part of the field the clearBall should be directed to. </td></tr>
    <tr><td class="paramname">angMax</td><td>if specified (and not NULL) will be filled with the angle between the opponents in the direction in which will be shot </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> kick command to clear the ball </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="aac84d06304774170af7b01162558da3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::collideWithBall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns a command that can be used to collide with the ball on purpose. When this is not possible. CMD_ILLEGAL is returned. Colliding with the ball may be useful when the player is turned with his back to the opponent goal and is intercepting a moving ball, by colliding both the ball and the player will loose all their velocity. Now the player can turn at once to the desired direction. Otherwise he first has to freeze the ball, freeze his own speed and then turn around. </p>

</div>
</div>
<a class="anchor" id="a22df9c1f41ddd210ffc6d97e56a2b904"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::communicate </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to communicate with other players on the field. It receives a string message as its only argument and returns a say command that causes the message to be broadcast to all players within a certain distance from the speaker. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to say the specified string 'str' </dd></dl>

</div>
</div>
<a class="anchor" id="af7da70e5ce312ed3e4365531f050195f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::dashToPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCycles</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sideDash</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method can be called to create a <a class="el" href="classSoccerCommand.html">SoccerCommand</a> that dashes to a point. This skill enables an agent to dash to a given point. It receives a global position 'pos' as its only argument and returns a dash command that causes the agent to come as close to this point as possible. Since the agent can only move forwards or backwards, the closest point to the target position that he can reach by dashing is the orthogonal projection of 'pos' onto the line that extends into the direction of his body (forwards and backwards). The power that must be supplied to the dash command is computed using the 'getPowerForDash' method which takes the position of 'pos' relative to the agent as input and 'iCycles' which denotes in how many cycles we want to reach that point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>global position to which the agent wants to dash </td></tr>
    <tr><td class="paramname">iCycles</td><td>desired number of cycles to reach point 'pos' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> dash command to move closer to 'pos' </dd></dl>

</div>
</div>
<a class="anchor" id="ad6be860b141f47cb33eec9f0a3762dd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::defendGoalLine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dDist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent (usually the goalkeeper) to defend his own goal line. To this end the agent moves to a position along a line l which runs parallel to the goal line at a small distance 'dDist' (supplied as an argument) from the goal. The guard point to which the agent moves depends on the predicted position of the ball in the next cycle and is chosen in anticipation of a future shot on goal. This means that the guard point is selected in such a way that it will be most difficult for the opponent team to pass the goalkeeper. To find this point we need to look at the angle that the ball makes with respect to the left and right goal posts and we need to determine which point on l covers this angle in the most optimal way, i.e. leaves an equal gap to the left and to the right of the goalkeeper. Let m be the line that goes through the center point of the goal line and through the predicted ball position in the next cycle. Since this line m bisects the above-mentioned angle, the optimal guard point on l can be computed by determining the intersection between l and m. Note that in our current implementation the goalkeeper always stays in front of the goal mouth to avoid leaving an open goal when the ball is passed to an opponent in the center of the penalty area. The computed guard point is therefore adjusted if it lies too far to the side . After computing the guard point the goalkeeper needs to move to this point while keeping sight of the ball. If the distance between the current goalkeeper position and the line l is larger than DefendGoalLineMaxDist (which has a value of 3.0 in our current implementation) the moveToPos skill is used to move directly towards the guard point. This can happen, for example, when the goalkeeper has moved forward from his line to intercept the ball and now has to move back to his line again. Note that the fourth argument supplied to the moveToPos skill equals true in this case to indicate that the goalkeeper wants to turn his back to the guard point in order to keep the ball in sight while moving. However, if the distance between the guard point and l is less than DefendGoalLineMaxDist then the moveToPosAlongLine skill is used to move along l to the guard point. This skill receives an argument `sign' representing a prediction of the agent's movement in the coming cycles. This value is used to adjust the agent's body direction when necessary. In this case it can be expected that the goalkeeper will move along l in the same direction as the ball and `sign' is therefore determined by looking at the ball velocity in cycle t.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dDist</td><td>distance before goal the goalkeeper will move along </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to defend the goal line. </dd></dl>

</div>
</div>
<a class="anchor" id="a687cc07033c6546931971f570c1e3a67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::directPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#ab93ab6e2460fd3f4ae01757ea619ee30">PassT</a>&#160;</td>
          <td class="paramname"><em>passType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to pass the ball directly to another player. It receives two arguments, 'pos' and 'passType', which respectively denote the position (of usually a teammate) to which the agent wants to pass the ball and the kind of pass (either normal or fast) that should be given. This skill uses the kickTo skill to pass the ball to the specified position with a certain desired end speed depending on the type of pass. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position of object to which a direct pass should be given </td></tr>
    <tr><td class="paramname">passType</td><td>kind of pass (either PASS_NORMAL or PASS_FAST ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to perform a direct pass to object 'o' </dd></dl>

</div>
</div>
<a class="anchor" id="a63e33779fbadff1b61a499c4176ac6f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::dribble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a>&#160;</td>
          <td class="paramname"><em>ang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#a0ccbf575eb8292e31644ccf3e84e3e3b">DribbleT</a>&#160;</td>
          <td class="paramname"><em>dribbleT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to dribble with the ball, i.e. to move with the ball while keeping it within a certain distance. This amounts to repeatedly kicking the ball at a certain speed into a desired direction and then intercepting it again. Two arguments, the angle 'ang' and type 'dribbleT', are supplied to this skill which respectively denote the global direction towards which the agent wants to dribble and the kind of dribble that must be performed. We distinguish three kinds of dribbling:</p><ul>
<li>DRIBBLE FAST: a fast dribble action in which the agent kicks the ball relatively far ahead of him.</li>
<li>DRIBBLE SLOW: a slower dribble action in which the agent keeps the ball closer than on a fast dribble.</li>
<li>DRIBBLE WITH BALL: a safe dribble action in which the agent keeps the ball very close to his body.</li>
</ul>
<p>It is important to realize that this skill is only called when the ball is located within the agent's kickable range. This means that it is only responsible for the kicking part of the overall dribbling behavior, i.e. it only causes the ball to be kicked a certain distance ahead into the desired direction 'ang'. If the absolute angle between 'ang' and the agent's body direction is larger than DribbleTurnAngle (which currently has a value of 30 degrees) then the agent uses the turnWithBallTo skill to turn with the ball towards the global angle 'ang'. Otherwise, he uses the kickTo skill to kick the ball into the desired direction towards a point that lies a certain distance ahead depending on the type of dribble. After the kick, the ball will move out of the agent's kickable range and as a result the agent will try to intercept it using the intercept skill. The dribbling skill can then be called again once the agent has succeeded in intercepting the ball. This sequence of kicking and intercepting will repeat itself until the agent decides to perform another skill. Note that during the dribble the power of a kick depends on the distance that the ball should travel and on the speed that it should have when it reaches the target point. In our current implementation this speed equals 0.5 (=DribbleKickEndSpeed) for any type of dribble. Experiments have shown that lower end speed values cause the agent to intercept the ball before it reaches the target point which slows the dribble down significantly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ang</td><td>global direction in which should be dribbled </td></tr>
    <tr><td class="paramname">dribbleT</td><td>type of dribble that should be performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to dribble in direction 'ang' </dd></dl>

</div>
</div>
<a class="anchor" id="a6edbb52467b3952693bc5e86d6230473"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::freezeBall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to freeze a moving ball, i.e. it returns a kick command that stops the ball dead at its current position. Since ball movement in the soccer server is implemented as a vector addition, the ball will stop in the next cycle when it is kicked in such a way that the resulting acceleration vector has the same length and opposite direction to the current ball velocity. The desired speed that should be given to the ball on the kick thus equals the current ball speed. Furthermore, the direction of the kick should equal the direction of the current ball velocity plus 180 degrees. Note that this direction must be made relative to the agent's global body angle before it can be passed as an argument to the kick command. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to freeze the ball. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b50d5fb9c7fa0e5a90a7e4a215bafc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVecPosition.html">VecPosition</a> BasicPlayer::getActiveInterceptionPointBall </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iCyclesBall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGoalie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method intercepts the ball at the first possible position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iCyclesBall</td><td>is the nr of cyles after the ball is intercepted </td></tr>
    <tr><td class="paramname">isGoalie</td><td>bool to indicate that a goalie has to intercept the ball </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>intercept position </dd></dl>

</div>
</div>
<a class="anchor" id="a95d6ecdb0d5f39f2644dc85e0da8cf3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BasicPlayer::getEndSpeedForPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>posPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns the end speed for a pass. This end speed is determined using two parameters, 'o' and 'posPass' which respectively denote the object to which is passed and the position to which is passed. First it is determined how many server cycles 'o' needs to travel to position 'posPass'. Then the starting speed of the ball is determined when it wants to travel to 'posPass' in the same number of cycles. This starting speed is adjusted if the corresponding end speed of the ball in the passing point lies outside the range [MinPassEndSpeed .. MaxPassEndSpeed]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>object to which the ball will be passed </td></tr>
    <tr><td class="paramname">posPass</td><td>desired passing point where o can intercept the ball </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>end speed to give to the ball such that player can intercept the ball the best. </dd></dl>

</div>
</div>
<a class="anchor" id="af6cd1d09c374231ae78e10d0636a644d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVecPosition.html">VecPosition</a> BasicPlayer::getInterceptionPointBall </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iMinCyclesBall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGoalie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method uses an iterative scheme to compute the optimal interception point of the ball. A loop is executed in which the prediction methods are used to predict the position of the ball a number of cycles, say i, into the future and to predict the number of cycles, say n, that the agent will need to reach this position. This is repeated for increasing values of i until n &lt; i in which case it is assumed thay the agent should be able to reach the predicted ball position before the ball does. This point is chosen as the interception point and the moveToPos skill is used to move towards this point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iCyclesToBall</td><td>will be filled with the nr of cycles it will take the ball to reach the returned position. </td></tr>
    <tr><td class="paramname">isGoalie</td><td>indicates whether the current player is a goalkeeper or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position to intercept the ball. </dd></dl>

</div>
</div>
<a class="anchor" id="a914a86746493fefae4af754011b4150e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVecPosition.html">VecPosition</a> BasicPlayer::getMarkingPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#a4cc7adc5fa3df60a8143bd51fc421f92">MarkT</a>&#160;</td>
          <td class="paramname"><em>mark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns a global position on the field which denotes the position to mark object 'o'. It receives three arguments: an object o (usually an opponent) that the agent wants to mark, a distance 'dDist' representing the desired distance between o and the marking position and a type indicator that denotes the type of marking that is required. We distinguish three types of marking:</p><ul>
<li>MARK BALL: marking the opponent by standing at a distance 'dDist' away from him on the line between him and the ball. This type of marking will make it di±cult for the opponent to receive a pass.</li>
<li>MARK GOAL: marking the opponent by standing at a distance 'dDist' away from him on the line between him and the center point of the goal he attacks. This type of marking will make it difficult for the opponent to score a goal.</li>
<li>MARK BISECTOR: marking the opponent by standing at a distance 'dDist' away from him on the bisector of the ball-opponent-goal angle. This type of marking enables the agent to intercept both a direct and a leading pass to the opponent. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>object that has to be marked </td></tr>
    <tr><td class="paramname">dDist</td><td>distance marking position is located from object position </td></tr>
    <tr><td class="paramname">mark</td><td>marking technique that should be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position that is the marking position. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="abf2b1236c259554ebdf96914ed2adb4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVecPosition.html">VecPosition</a> BasicPlayer::getShootPositionOnLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> *&#160;</td>
          <td class="paramname"><em>angLargest</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns the point on a line segment with which the ball has the largest angle with the surrounding opponents. It uses the method getDirectionOfWidestAngle. The line is determined by the two position p1 and p2. The returned position lies on this line and makes the largest angle with the opponents. The actual angle between the opponents is returned by 'angLargest'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>first position of line segment </td></tr>
    <tr><td class="paramname">p2</td><td>second position of line segment </td></tr>
    <tr><td class="paramname">*angLargest</td><td>will be filled with the largest angle with the opponents </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classVecPosition.html">VecPosition</a> position on line that has the largest angle with the opponents </dd></dl>

</div>
</div>
<a class="anchor" id="a803fc819ba92d02bf244d883f0f76203"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVecPosition.html">VecPosition</a> BasicPlayer::getThroughPassShootingPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a>&#160;</td>
          <td class="paramname"><em>objTeam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>posEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> *&#160;</td>
          <td class="paramname"><em>angMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns the shooting point for a through pass to objTeam. This point lies on the line l that is created of the estimated position of the teammate after 3 cycles and 'posEnd'. Between these two points the maximal angle with respect to the opponents is calculated and the widest angle is calculated (this value is stored in angMax afterwards). The intersection between this widest angle and the line l is returned as the shooting point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objTeam</td><td>teammate to give a throughpass to </td></tr>
    <tr><td class="paramname">posEnd</td><td>end point to which throughpasses are considered </td></tr>
    <tr><td class="paramname">angMax</td><td>will be filled with the maximal angle between the opponents </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position to give a through pass to. </dd></dl>

</div>
</div>
<a class="anchor" id="a6927be949526b68617b8663eae9e2b7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::holdBall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns a command to hold the ball close to your body. When no opponents are close the ball is kicked in front of the body of the agent. Otherwise it is kiced to that spot in the kickable distance which is hardest for the opponent to tackle. </p>

</div>
</div>
<a class="anchor" id="af6b9642a2abd6f5f3fc359589d1373d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::intercept </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGoalie</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When the ball-interception skill is called, it is first determined whether it is possible for the agent to intercept the ball within two cycles using the intermediate player skill closeIntercept (for the goalkeeper closeIntereptGoalie). If it turns out that the ball cannot be intercepted within two cycles then the agent uses an iterative scheme to compute the optimal interception point. This is done using the method 'getInterceptionPointBall'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isGoalie</td><td>indicates whether the current player is a goalkeeper or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to intercept the ball. </dd></dl>

</div>
</div>
<a class="anchor" id="abcee3b0e4dadf0305022280beaf5991e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::interceptClose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to intercept a ball which is close to him. The objective is to move in such a way that the ball will come within the kickable distance from the agent in one or two cycles. To this end the prediction methods from the world model are used to predict the ball position in the next cycle and two cycles into the future. It is then determined whether it is possible to move the agent within kickable distance from one of these positions using all logical combinations of turn and dash commands. If it is not possible to intercept the ball within two cycles then this skill returns an illegal command to indicate that it cannot be performed. First it is determined whether the agent can intercept the ball in one cycle. To this end the position of the ball in the next cycle is predicted and a calculation is performed to decide whether a single dash can move the agent within the kickable distance from this position. In order to be able to kick the ball efficiently after intercepting it, it is important that the agent moves to a good position relative to the ball (i.e. the ball must be in front of him). At the same time the agent must make sure that he does not collide with the ball when trying to intercept it. Let l be a line that runs forwards and backwards from the predicted position of the agent in the next cycle into the direction of his body. This line thus denotes the possible movement direction of the agent. Note that we have to use the agent's predicted position in the next cycle since his current velocity must be taken into account. In addition, let c be a circle which is centered on the predicted ball position and which has a radius equal to the sum of the radius of the agent, the radius of the ball and a small buffer (kickable margin/6). It is now determined whether the agent can intercept the ball in the next cycle by looking at the number of intersection points between l and c. If l and c have exactly one point in common then this point is the desired interception point for the next cycle. However, if the number of intersection points equals two then the desired point is the one for which the absolute angle of the ball relative to that point is the smallest. This amounts to the intersection point which is closest to the agent when the ball lies in front of him and to the furthest one when the ball is behind his back. As a result, the desired interception point will always be such that the agent has the ball in front of him in the next cycle. Then a dash command is generated that will bring the agent as close as possible to the desired point. Next, the position of the agent after executing this command is predicted and if it turns out that this predicted position lies within the kickable distance from the ball then the dash is performed. However, if the predicted position is not close enough to the ball or if l and c have no points in common then it is assumed that the ball cannot be intercepted with a single dash. In these cases, two alternatives are explored to see if the ball can be intercepted in two cycles. The first alternative is to determine whether the agent can intercept the ball by performing a turn followed by a dash. To this end the global position of the ball is predicted two cycles into the future and a turn command is generated that will turn the agent towards this point. The agent's position after executing this command is then predicted after which a dash command is generated that will bring the agent as close as possible to the predicted ball position in two cycles. If it turns out that the predicted position of the agent after the dash lies within kickable distance from the ball then the first command (i.e. the turn) in the sequence of two is performed. Otherwise, a second alternative is tried to determine whether the agent can intercept the ball by performing two dash commands. To this end two dash commands are generated to get closer to the predicted ball position after two cycles. If the predicted position of the agent after these two dashes lies within kickable distance from the ball then the first dash is performed. Otherwise, an illegal command is returned to indicate that the skill cannot be performed. The close interception procedure is heavily based on a similar method introduced in CMU'99 by Peter Stone. </p><dl class="section return"><dt>Returns</dt><dd>command to intercept ball in two cycles, CMD_ILLEGAL otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a93a7e41c8b11d8fe6b92f950141a6ec3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::interceptCloseGoalie </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables a goalkeeper to intercept a ball which is close to him. The objective is to move in such a way that the ball will come within the catchable distance from the agent in one or two cycles. To this end the prediction methods from the world model are used to predict the ball position in the next cycle and two cycles into the future. It is then determined whether it is possible to move the agent within the catchable area from one of these positions using all logical combinations of turn and dash commands. If it is not possible to intercept the ball within two cycles then this skill returns an illegal command to indicate that it cannot be performed. First it is determined whether the goalkeeper can intercept the ball in one cycle. To this end the position of the ball in the next cycle is predicted and a calculation is performed to decide whether a single dash can move the agent within catchable distance from this position. If it turns out that this is the case, the corresponding dash is performed. However, if the predicted position is not close enough to the ball then it is assumed that the ball cannot be intercepted with a single dash. In these cases, two alternatives are explored to see if the ball can be intercepted in two cycles. The first alternative is to determine whether the agent can intercept the ball by performing two dash commands. To this end two dash commands are generated. If the predicted position of the agent after these two dashes lies within catchable distance from the ball then the first dash is performed. Otherwise, a second alternative is tried to determine whether the agent can intercept the ball by performing a turn followed by a dash. To this end the global position of the ball is predicted two cycles into the future and a turn command is generated that will turn the agent towards this point. The agent's position after executing this command is then predicted after which a dash command is generated that will bring the agent as close as possible to the predicted ball position. If it turns out that the predicted position of the agent after the dash lies within catchable distance from the ball then the first command (i.e. the turn) in the sequence of two is performed. Otherwise, an illegal command is returned to indicate that the skill cannot be performed. The close interception procedure is heavily based on the method used by CMU'99 by Peter Stone. </p><dl class="section return"><dt>Returns</dt><dd>command to intercept ball in two cycles, CMD_ILLEGAL otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a20ea44e2d6f0105ae521c9ac9bf407ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::interceptScoringAttempt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns a command to intercept a ball that is currently heading towards the goal. The current trajectory of the ball is determined and the goalkeeper positions himself on a point on this trajectory just before the goal. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to intercept a ball heading towards the goal. </dd></dl>

</div>
</div>
<a class="anchor" id="a517b7d4ef489a3476662939019e1d66d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::kickBallCloseToBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a>&#160;</td>
          <td class="paramname"><em>ang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dKickRatio</em> = <code>0.16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to kick the ball close to his body. It receives an angle 'ang' as its only argument and returns a kick command that causes the ball to move to a point at a relative angle of 'ang' degrees and at a close distance (kickable margin/6 to be precise) from the agent's body. To this end the ball has to be kicked from its current position to the desired point relative to the predicted position of the agent in the next cycle. In general, this skill will be used when the agent wants to kick the ball to a certain position on the field which cannot be reached with a single kick. Since the efficiency of a kick is highest when the ball is positioned just in front of the agent's body, calling this skill with 'ang = 0' will have the effect that the agent can kick the ball with more power after it is executed. Note that this skill will only be executed if it is possible to actually reach the desired ball position with a single kick. If the required power does exceed the maximum then the ball is frozen at its current position using the freezeBall skill. In general, it will then always be possible to shoot the motionless ball to the desired point in the next cycle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">'ang'</td><td>relative angle to body to which the ball should be kicked </td></tr>
    <tr><td class="paramname">relative</td><td>ratio to which the ball is kicked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to kick the ball close to the body </dd></dl>

</div>
</div>
<a class="anchor" id="a502eaf4aa2a5ba85af56f6863e767395"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::kickTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>posTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dEndSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to kick the ball from its current position to a given position 'posTarget' in such a way that it has a remaining speed equal to 'dEndSpeed' when it reaches this position. However, it is possible that the ball cannot reach this velocity with a single kick either because the needed magnitude of the generated velocity vector exceeds the maximum speed of the ball or due to the fact that the current ball speed in combination with the position of the ball relative to the agent make it impossible to achieve the required acceleration. If the magnitude of needed velocity vector is larger than ball speed max it is certain that even in the optimal situation (i.e. if the ball lies directly in front of the agent and has zero velocity) the agent will not be able to kick the ball to the target position at the desired speed. In this case the expected ball movement is computed after executing a kick with maximum power into the direction of 'posTarget'. If the magnitude of the resulting movement vector is larger than a given percentage ('getPlayerWhenToKick' defined in the <a class="el" href="classPlayerSettings.html">PlayerSettings</a>) of the maximum ball speed then this kick is actually performed despite the fact that it cannot produce the wanted effect. Otherwise, the agent shoots the ball close to his body and directly in front of him using the kickBallCloseToBody skill. In this way he will be able to kick the ball with more power in the next cycle. However, if the magnitude of the desired velocity vector is smaller than ball speed max it is possible to reach the target point at the desired speed in the optimal situation. If the power that must be supplied to the kick command to achieve this acceleration is less than or equal to the maximum power the accelerateBallToVelocity skill is used to perform the desired kick. Otherwise, the agent uses the kickBallCloseToBody skill to put the ball in a better kicking position for the next cycle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posTarget</td><td>target position where the ball should be shot to </td></tr>
    <tr><td class="paramname">endSpeed</td><td>desired speed ball should have in target position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> that produces kick </dd></dl>

</div>
</div>
<a class="anchor" id="a9c6793780826b51a126102c5d29707ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::leadingPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#a8e832a4ec6c67d3151112ed1e1c67752">DirectionT</a>&#160;</td>
          <td class="paramname"><em>dir</em> = <code><a class="el" href="SoccerTypes_8h.html#a8e832a4ec6c67d3151112ed1e1c67752a944af66843e2c071955de8dfc4e7f407">DIR_NORTH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to give a leading pass to another player. A leading pass is a pass into open space that `leads' the receiver, i.e. instead of passing the ball di:rectly to another player it is kicked just ahead of him. In this way the receiver is able to intercept the ball while moving in a forward direction and this will speed up the attack. This skill receives two arguments, an object o (usually a teammate) and dist, which respectively denote the intended receiver of the leading pass and the `leading distance' ahead of the receiver. It uses the kickTo skill to pass the ball to a point that lies dist in front of the current position of o. Here `in front of' means in positive x-direction, i.e. at a global angle of 0 degrees. Note that the desired end speed for a leading pass is always equal to PassEndSpeed (currently 1.4) since the leading aspect of the pass might cause the receiver to miss the ball when its speed is higher. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>object to which a leading pass should be given </td></tr>
    <tr><td class="paramname">dDist</td><td>distance in front of o to which is passed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to perform a leading pass to object 'o' </dd></dl>

</div>
</div>
<a class="anchor" id="a4e9844c2ef6e7c53c604835c9423638a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::listenTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a>&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns a 'attentionto' command to listen to the specified object. In most occasions this is a teammate. </p>

</div>
</div>
<a class="anchor" id="ac5217a00d71206eaf17bf3656bd6f995"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#a4cc7adc5fa3df60a8143bd51fc421f92">MarkT</a>&#160;</td>
          <td class="paramname"><em>mark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to mark an opponent, i.e. to guard him one-on-one with the purpose to minimize his usefulness for the opponent team. It can be used, for example, to block the path from the ball to an opponent or from an opponent to the goal. In this way the agent can prevent this opponent from receiving a pass or from moving closer to the goal while also obstructing a possible shot. This skill amounts to calculating the desired marking position based on the given arguments and then moving to this position. It receives three arguments: an object o (usually an opponent) that the agent wants to mark, a distance 'dDist' representing the desired distance between o and the marking position and a type indicator that denotes the type of marking that is required. We distinguish three types of marking:</p><ul>
<li>MARK BALL: marking the opponent by standing at a distance 'dDist' away from him on the line between him and the ball. This type of marking will make it di±cult for the opponent to receive a pass.</li>
<li>MARK GOAL: marking the opponent by standing at a distance 'dDist' away from him on the line between him and the center point of the goal he attacks. This type of marking will make it difficult for the opponent to score a goal.</li>
<li>MARK BISECTOR: marking the opponent by standing at a distance 'dDist' away from him on the bisector of the ball-opponent-goal angle. This type of marking enables the agent to intercept both a direct and a leading pass to the opponent.</li>
</ul>
<p>After determining the marking position, the agent uses the moveToPos skill to move to this position. Note that the decision whether to turn or dash in the current situation depends on the angle of the marking position relative to the agent's body direction and on the distance to this position if this point lies behind the agent. In this case the moveToPos skill uses the threshold parameters MarkTurnAngle (=30) and MarkDistanceBack (=3) to make this decision. The values for these parameters are such that the condition which must hold for allowing a dash is fairly flexible. This is done because the marking position will be different in consecutive cycles due to the fact that the opponent and the ball move around from each cycle to the next. As a result, the agent will be able to actually progress towards a point that lies close to the marking position instead of constantly turning towards the newly calculated marking position in each cycle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>object that has to be marked </td></tr>
    <tr><td class="paramname">dDist</td><td>distance marking position is located from object position </td></tr>
    <tr><td class="paramname">mark</td><td>marking technique that should be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to mark object 'o'. </dd></dl>

</div>
</div>
<a class="anchor" id="a0310219cd313d63785a72d482db2348b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::moveToPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>posTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a>&#160;</td>
          <td class="paramname"><em>angWhenToTurn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dDistBack</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMoveBack</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCycles</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to move to a global position 'pos' on the field which is supplied to it as an argument. Since the agent can only move forwards or backwards into the direction of his body, the crucial decision in the execution of this skill is whether he should perform a turn or a dash. Turning has the advantage that in the next cycle the agent will be orientated correctly towards the point he wants to reach. However, it has the disadvantage that performing the turn will cost a cycle and will reduce the agent's velocity since no acceleration vector is added in that cycle. Apart from the target position 'pos', this skill receives several additional arguments for determining whether a turn or dash should be performed in the current situation. If the target point is in front of the agent then a dash is performed when the relative angle to this point is smaller than a given angle 'angWhenToTurn'. However, if the target point is behind the agent then a dash is only performed if the distance to point is less than a given value 'dDistBack' and if the angle relative to the back direction of the agent is smaller than 'angWhenToTurn'. In all other cases a turn is performed. Note that in the case of the goalkeeper it is sometimes desirable that he moves backwards towards his goal in order to keep sight of the rest of the field. To this end an additional boolean argument 'bMoveBack' is supplied to this skill that indicates whether the agent should always move backwards to the target point. If this value equals true then the agent will turn his back towards the target point if the angle relative to his back direction is larger than 'angToTurn'. In all other cases he will perform a (backward) dash towards 'posTo' regardless of whether the distance to this point is larger than 'dDistBack'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posTo</td><td>global target position to which the agent wants to move </td></tr>
    <tr><td class="paramname">angWhenToTurn</td><td>angle determining when turn command is returned </td></tr>
    <tr><td class="paramname">dDistBack</td><td>when posTo lies closer than this value to the back of the agent (and within angWhenToTurn) a backward dash is returned </td></tr>
    <tr><td class="paramname">bMoveBack</td><td>boolean determing whether to move backwards to 'posTo' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> that determines next action to move to 'posTo' </dd></dl>

</div>
</div>
<a class="anchor" id="a69ab617e6e772c686efec2d94d780723"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::moveToPos2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>posTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a>&#160;</td>
          <td class="paramname"><em>angWhenToTurn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function does the same thing that the function moveToPos, but it adds the dash direction as the second argument ofthe dash command, in order to make a side dash.</p>
<p>Warning: This function does not check if the angle passed is accepted by server. Nowadays, the server 13.1 accepts only the directions: -180, -90, 0, 90, 180 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posTo</td><td>global target position to which the agent wants to move </td></tr>
    <tr><td class="paramname">angWhenToTurn</td><td>angle determining when turn command is returned </td></tr>
    <tr><td class="paramname">angle</td><td>the direction for the dash command. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> that determines next action to move to 'posTo' </dd></dl>

</div>
</div>
<a class="anchor" id="a05e0fa368dc255e0d36c5d4b72d23899"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::moveToPosAlongLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a>&#160;</td>
          <td class="paramname"><em>ang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dDistThr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iSign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a>&#160;</td>
          <td class="paramname"><em>angThr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a>&#160;</td>
          <td class="paramname"><em>angCorr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to move along a line to a given position 'pos' on this line. It is used, for example, by the goalkeeper who often wants to stay on a line in front of his goal and move to different positions on this line depending on where the ball is located. Furthermore, it can also used by defenders for marking an opponent player by moving along a line between this player and the ball. The idea is that the agent must try to move as fast as possible to the desired point 'pos' along the line thereby keeping the number of turns to a minimum to avoid wasting cycles. Apart from the target position 'pos', this skill receives several additional arguments for determining whether the agent should turn or dash in the current situation. Since the agent can only move forwards or backwards into the direction of his body, it is important that he tries to keep the orientation of his body aligned with the direction of the line in order to be able to move quickly to the target point. A given angle 'ang' denotes the desired body angle (global) of the agent in the point 'pos'. The line l can thus be defined as going through 'pos' and having global direction 'ang'. Due to the noise that is added to the movement of the agent, the orientation of his body will never be exactly equal to 'ang' and as a result the agent' s position will start to deviate from the line. Each time when this skill is called, the agent's desired orientation is therefore slightly adjusted depending on his position with respect to l. If the distance d between the agent's current position and the line l is smaller than the given value 'dDistThr' then 'ang' remains unchanged. However, if d exceeds 'dDistThr' then 'ang' is adjusted in such a way that the agent will move closer to l in subsequent cycles. This is done by either increasing or decreasing the desired orientation 'ang' by 'angCorr' degrees depending on which side of the line the agent is located and on a prediction of the agent's movement in the forthcoming cycles. This prediction is represented by a given value 'iSign' which equals 1 if the agent is expected to move in the same direction as 'ang' and -1 if he will move in the opposite direction. Adjusting 'ang' in this way has the effect that in subsequent cycles the agent will move closer to the line again if this is necessary. The final decision whether to turn or dash is now made by comparing the agent's current body angle to the desired orientation. If the difference between these two angles is larger than 'angThr' degrees then the agent uses the turnBodyToPoint skill to turn in the desired direction. Otherwise, the dashToPoint skill is called to move towards the target position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>global position to which the agent wants to move </td></tr>
    <tr><td class="paramname">ang</td><td>desired global body angle of agent in position 'pos' </td></tr>
    <tr><td class="paramname">dDistThr</td><td>threshold value that defines if desired angle is adjusted </td></tr>
    <tr><td class="paramname">iSign</td><td>indication whether agent predicts that he will move in the same direction as 'ang' in the subsequent cycles (iSign=1) or in the opposite direction (iSign=-1) </td></tr>
    <tr><td class="paramname">angThr</td><td>threshold value that specifies when agent will perform a turn command </td></tr>
    <tr><td class="paramname">angCorr</td><td>correction term with which angle is adjusted if necessary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> that will move agent along line defined by position 'pos' and angle 'ang'. </dd></dl>

</div>
</div>
<a class="anchor" id="ae16c69a2f51d2eafd1e01ae6664059fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::outplayOpponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a> *&#160;</td>
          <td class="paramname"><em>posTo</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to outplay an opponent. It is used, for example, when an attacker wants to get past an enemy defender. This is done by passing the ball to open space behind the defender in such a way that the attacker can beat the defender to the ball. Note that the attacker has an advantage in this situation, since he knows to which point he is passing the ball and is already turned in the right direction, whereas the defender is not. As result, the attacker has a headstart over the defender when trying to intercept the ball. Since a player can move faster without the ball, the main objective is to kick the ball as far as possible past the opponent while still being able to reach it before the opponent does. This skill receives two arguments, 'pos' and 'o', which respectively denote the point to which the agent wants to move with the ball and the object (usually an opponent) that the agent wants to outplay in doing so. First it is determined if it is possible to outplay the opponent o in the current situation. Let l be the line segment that runs from the agent's current position to the given point 'pos'. The best point to kick the ball to will be the furthest point from on this line that the agent can reach before the opponent does. We use a simple geometric calculation to find the point s on l which has equal distance to the agent and to the opponent. Let o' be the perpendicular projection of the opponent's position onto l and let d1, d2 and d3 respectively denote the distance between the agent poisition and o', the distance between o' and o and the distance between o' and s. To determine s we need to compute the unknown value of d3 using the values for d1 and d2 which can be derived from the world model. Since the distance from the agent position to s will be equal to the distance from o to s. Using this value for d3 we can compute the coordinates of the shooting point s. However, in some situations it is not likely that shooting the ball to this point will eventually result in outplaying the given opponent o on the way to 'pos'. We therefore use the values for d1, d2 and d3 to determine whether it is possible to outplay o in the current situation, and if so, what the best shooting point will be. The following situations are distinguished:</p><ul>
<li>d1 + d3 &gt; OutplayMinDist. If this condition holds, the opponent is located at a relatively large distance from the agent which makes an attempt to outplay him likely to be successful. First it is checked whether the agent's body is turned suffiiently towards the point 'pos'. If this is not the case then the turnWithBallTo skill is used to turn with the ball in the right direction. Otherwise, the kickTo skill is used to kick the ball to a point on the line l where the agent will be able to intercept it first. Note that in general the agent will be able to reach the point s before the opponent despite the fact that both players need to travel the same distance to this point. This is because the agent has already turned his body more or less towards 'pos' (and thus towards s), whereas the opponent probably has not. However, the actual point to which the ball is kicked is chosen slightly closer to the agent than the point s in order to be absolutely sure that he can intercept the ball before the opponent does. This safety margin is represented by the parameter OutplayBuffer which has a value of 2.5 in our current implementation. For this skill the desired end speed when the ball reaches z equals OutplayKickEndSpeed (=0.5). Note that the value for this parameter cannot be chosen too low, since this will cause the agent to intercept the ball before it reaches the target point</li>
<li>d1 + d3 &lt; OutplayMinDist and d1 &lt; d2. If this condition holds, the opponent is located close to the agent which makes it di±cult to outplay him. However, if the agent is already turned in the right direction (i.e. towards 'pos') then d1 &lt; d2 implies that the distance between the opponent and the line l (denoting the agent's desired movement trajectory) is large enough for the agent to outplay this opponent when the ball is kicked hard in the direction of 'pos' (i.e. further ahead than s). This is because the agent can start dashing after the ball immediately, whereas the opponent still has to turn in the right direction. As a result, the agent will have dashed past the opponent by the time the latter has turned correctly and this puts him in a good position to intercept the ball before the opponent. Therefore it is checked first whether the agent's body is sufficiently turned towards 'pos' and if this is not so then the turnWithBallTo skill is used toturn with the ball in the right direction. Otherwise, the kickTo skill is used to kick the ball past the opponent. In this case the point to which the ball is kicked either lies OutplayMaxDist (=20) metres ahead of the agent's current position into the direction of 'pos' or equals 'pos' when the distance to 'pos' is smaller than this value. In all other cases (i.e. d1 +d3 &lt; OutplayMinDist and d1 &gt; d2) this skill returns an illegal command to indicate that it is not possible to outplay the opponent o on the way to the point 'pos'. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>opponent object that should be outplayed </td></tr>
    <tr><td class="paramname">pos</td><td>position to which agent wants to move while outplaying 'o' </td></tr>
    <tr><td class="paramname">*posTo</td><td>position to which ball will be shot </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to outplay object o on the way to 'pos', CMD_ILLEGAL when this is not possible. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ad9700140b78ffeb1794366cf63836e21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::searchBall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to search for the ball when he cannot see it. It returns a turn command that causes the agent to turn his body by an angle that equals the width of his current view cone (denoted by the ViewAngle attribute in the <a class="el" href="classAgentObject.html">AgentObject</a> class). In this way the agent will see an entirely different part of the field after the turn which maximizes the chance that he will see the ball in the next cycle. Note that the agent turns towards the direction in which the ball was last observed to avoid turning back and forth without ever seeing the ball. Furthermore the inertia moment of the agent is taken into account to compensate for the current speed of the agent. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> that searches for the ball. </dd></dl>

</div>
</div>
<a class="anchor" id="a987d8442964607644adf5bcd539a0659"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::tackle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>powerOrAngle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns the command to tackle the ball. </p>

</div>
</div>
<a class="anchor" id="a22ffa701a6b2da41c70b60a8c244d96d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::teleportToPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns a 'move' command to teleport the agent directly to the specified global position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>global position to which should be moved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to move directly to 'pos'. </dd></dl>

</div>
</div>
<a class="anchor" id="aca8ea920641ef60220f1ff9ce4975268"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::throughPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>posEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a> *&#160;</td>
          <td class="paramname"><em>angMax</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to give a more advanced type of pass called a through pass. With a through pass the ball is not passed directly to another player or just ahead of him, but it is kicked into open space between the opponent defenders and the opponent goalkeeper in such a way that a teammate (usually an attacker) will be able to reach the ball before an opponent does. If a through pass is executed successfully it often causes a disorganization of the opponent's defense which will enable an attacker to get the ball close to the enemy goal. This skill takes an object o (usually a teammate) as an argument which denotes the intended receiver of the through pass. The position p on the field to which the ball should be kicked is determined by drawing a line l from the object's current position to a given point 'pos' also supplied as an argument) and by computing the safest trajectory for the ball to a point on this line. To this end the widest angle between opponents from the current ball position to a point p on l is calculated. After this, the speed that the ball should have when it reaches this point is determined based on the distance from the current ball position to p and on the number of cycles n that o will need to reach p. If it turns out that the required end speed falls outside the range [MinPassEndSpeed .. MaxPassEndSpeed] it is set to the closest boundary of this range. The kickTo skill is then used to kick the ball to the desired point p at the required speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td><a class="el" href="classObject.html">Object</a> to which through pass should be given </td></tr>
    <tr><td class="paramname">posEnd</td><td>position that together with ball position defines line segment on which shooting point should be determined. </td></tr>
    <tr><td class="paramname">*angMax</td><td>will be filled with the largest angle between the opponents </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> to give a throughPass to 'o' </dd></dl>

</div>
</div>
<a class="anchor" id="acb667ad61ced5f4fea1b6552d7a218ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::turnBackToPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCycles</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to turn his back towards a given point 'pos'. The only difference between this skill and turnBodyToPoint is that the angle between the given position and the predicted position of the agent in the next cycle is now made relative to the back of the agent by subtracting the agent's global back direction. This skill can for example be used by the goalkeeper in case he wants to move back to his goal while keeping sight of the rest of the field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to which the agent's back should be turned </td></tr>
    <tr><td class="paramname">iCycles</td><td>denotes the number of cycles that are used to update the the agent position. The resulting position is compared with 'pos' to determine the desired turning angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> command to turn agent's back to the desired point </dd></dl>

</div>
</div>
<a class="anchor" id="a9374629af78e897891ab992a21f85f2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::turnBodyToObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a>&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to turn his body towards an object o which is supplied to it as an argument. To this end the object's global position o in the next cycle is predicted based on its current velocity. This predicted position is passed as an argument to the turnBodyToPoint skill which generates a turn command that causes the agent to turn his body towards the object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>object to which agent wants to turn </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> that turns to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a4f4762b6f8a9938bd5142bee0865a72e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::turnBodyToPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCycles</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to turn his body towards a given point. It receives a global position 'pos' on the field and returns a turn command that will turn the agent's body towards this point. To this end the agent's global position in the next cycle is predicted based on his current velocity. This is done to compensate for the fact that the remaining velocity will move the agent to another position in the next cycle. The global angle between the given position and the predicted position is then determined after which the agent's global body direction is subtracted from this angle in order to make it relative to the agent's body. Finally, the resulting angle is normalized and adjusted to compensate for the inertia moment and speed of the agent. If it is impossible to turn towards the given position in a single cycle then the agent turns as far as possible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to which body should be turned </td></tr>
    <tr><td class="paramname">iCycles</td><td>denotes the number of cycles that are used to update the the agent position. The resulting position is compared with 'pos' to determine the desired turning angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> turn command to turn body to the desired point </dd></dl>

</div>
</div>
<a class="anchor" id="aaf8a6bc96a2cafcf33fd2f4daabc1de0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::turnNeckToObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SoccerTypes_8h.html#ad4b701fa66e7d26c054ed15b7820c77c">ObjectT</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td>
          <td class="paramname"><em>soc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to turn his neck towards an object. It receives as arguments this object o as well as a primary action command 'soc' that will be executed by the agent at the end of the current cycle. Turning the neck towards an object amounts to predicting the object's global position in the next cycle and passing this predicted position together with the 'soc' command as arguments to the turnNeckToPoint skill. This low-level skill will then generate a turn neck command that causes the agent to turn his neck towards the given object. Note that the 'soc' command is supplied as an argument for predicting the agent's global position and neck angle after executing the command. This is necessary because a turn neck command can be executed in the same cycle as a kick, dash, turn , move or catch command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>object to which the agent wants to turn his neck </td></tr>
    <tr><td class="paramname">soc</td><td><a class="el" href="classSoccerCommand.html">SoccerCommand</a> that is performed in this cycle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> that turns the neck of the agent to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a651d2599323445ef450bd9af94c5c7ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::turnNeckToPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVecPosition.html">VecPosition</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSoccerCommand.html">SoccerCommand</a>&#160;</td>
          <td class="paramname"><em>soc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to turn his neck towards a given point. It receives a global position 'pos' on the field as well as a primary action command 'soc' that will be executed by the agent at the end of the current cycle and returns a turn neck command that will turn the agent's neck towards 'pos'. To this end the agent's global position and neck direction after executing the cmd command are predicted using methods from the world model. The global angle between the given position and the predicted position is then determined after which the predicted neck direction is subtracted from this angle in order to make it relative to the agent's neck. Finally, the resulting angle is normalized and directly passed as an argument to the turn neck command since the actual angle with which a player turns his neck is by definition equal to this argument. If the resulting turn angle causes the absolute angle between the agent's neck and body to exceed the maximum value, then the agent turns his neck as far as possible. Note that it is necessary to supply the selected primary command as an argument to this skill, since a turn neck command can be executed in the same cycle as a kick, dash, turn , move or catch command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position to which neck should be turned </td></tr>
    <tr><td class="paramname">soc</td><td><a class="el" href="classSoccerCommand.html">SoccerCommand</a> that is executed in the same cycle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classSoccerCommand.html">SoccerCommand</a> turn command to turn neck to the desired point </dd></dl>

</div>
</div>
<a class="anchor" id="a6b8241babfa3f51132484b2ff73af042"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSoccerCommand.html">SoccerCommand</a> BasicPlayer::turnWithBallTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a>&#160;</td>
          <td class="paramname"><em>ang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Geometry_8h.html#a6bfe02ae9bb185092902092561ab2865">AngDeg</a>&#160;</td>
          <td class="paramname"><em>angKickThr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dFreezeThr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This skill enables an agent to turn towards a global angle while keeping the ball in front of him. It is used, for example, when a defender has intercepted the ball in his defensive area and faces his own goal. In this situation the defender usually wants to pass the ball up the field into an area that is currently not visible to him and to this end he will first use this skill to turn with the ball towards the opponent's goal. Turning with the ball requires a sequence of commands to be performed. The ball first has to be kicked to a desired position relative to the agent, then it has to be stopped dead at that position and finally the agent must turn towards the ball again. Each time when this skill is called it has to be determined which part of the sequence still has to be executed. This is done as follows. If the absolute difference between the desired angle and the global angle of the ball relative to the position of the agent is larger than the value 'angKickThr' then the kickBallCloseToBody skill is used to kick the ball to a position close to the agent and at the desired angle. Otherwise, it is checked whether the ball still has speed from the previous action. If the remaining ball speed exceeds the given value 'dFreezeThr' then the ball is stopped dead at its current position using the freezeBall skill. In all other cases the agent turns his body towards the specified angle 'ang'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ang</td><td>global direction in which ball and player should be faced </td></tr>
    <tr><td class="paramname">angKickThr</td><td>when ball angle difference is larger than this value ball is repositioned </td></tr>
    <tr><td class="paramname">dFreezeThr</td><td>when ball lies correct, but has speed higher than this value, ball is frozen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Soccercommand to turn with the ball to global angle 'ang'. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="adb559ebfe52c2ca1b01cc21655bbed10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classActHandler.html">ActHandler</a>* BasicPlayer::ACT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classActHandler.html">ActHandler</a> to which commands can be sent </p>

</div>
</div>
<a class="anchor" id="aef9a4fafd096a406d0ef5f85d11907b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPlayerSettings.html">PlayerSettings</a>* BasicPlayer::PS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All parameters used for the player </p>

</div>
</div>
<a class="anchor" id="a16daddc5f23e5862d115d1913a93fc1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServerSettings.html">ServerSettings</a>* BasicPlayer::SS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All parameters used by the server </p>

</div>
</div>
<a class="anchor" id="a0a0a8b87ce4d8b6ad94a0fe594274715"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWorldModel.html">WorldModel</a>* BasicPlayer::WM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classWorldModel.html">WorldModel</a> that contains information of world </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="BasicPlayer_8h_source.html">BasicPlayer.h</a></li>
<li>src/<a class="el" href="BasicPlayer_8cpp.html">BasicPlayer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
